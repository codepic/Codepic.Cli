---
applyTo: "modules/**/*.tasks.functions.ps1"
---

# Codepic CLI task helper instructions

## Purpose

Task-specific functions keep Invoke-Build task definitions approachable while preserving shared behavior in one place. Treat each `*.tasks.functions.ps1` as the canonical home for reusable logic scoped to its matching task file so contributors retain IntelliSense, comment-based help, and an uncluttered Invoke-Build surface. Skip a single top-level comment-based help block here; instead, document each function individually so hover help explains that specific helper. These full-fledged functions are also prime targets for Pester tests and can be mocked in task-level test suites. Use these guidelines whenever you introduce a companion file.

## Authoring conventions

- Start each helper file with comment-based help that briefly explains which task file it supports and the scenarios it enables.
- Export helper logic through standard PowerShell functions only—do not declare `task {}` blocks or perform side-effectful work at the top level.
- Scope functions narrowly to the needs of the matching task file (for example, `modules/example.tasks.ps1` pairs with `modules/example.tasks.functions.ps1`). If multiple task files need the same helper, prefer a shared module instead of cross-linking helpers.
- Precede every function with comment-based help that includes, at minimum, `.SYNOPSIS`, `.DESCRIPTION`, `.PARAMETER` entries covering each declared parameter, and `.EXAMPLE` entries that demonstrate each mandatory parameter individually and every optional parameter at least once. Add `.NOTES` or additional sections when they clarify behavior or constraints.
- Only introduce a helper when it measurably reduces duplicated logic or increases clarity—do not wrap native commands (such as `Get-Content` piped to `ConvertFrom-Json`) in thin pass-through functions that provide no extra semantics.
- Name functions using the pattern `Verb-<Module>Noun`, where `<Module>` is the Pascal-cased module folder name; omit the module prefix entirely for the root module (e.g., `Invoke-CliAliasSetup` for `modules/cli`, but `Invoke-AliasSetup` for the root module). Approved verbs must come from `Get-Verb`; avoid custom verbs so `PSUseApprovedVerbs` stays satisfied.
- Keep functions focused and readable; refactor long workflows into smaller private helpers rather than embedding complex branching in a single function.
- Guard incoming parameters with validation attributes (`[ValidateNotNullOrEmpty()]`, `[ValidateSet()]`, etc.) so tasks can trust the helpers they call.
- Avoid referencing global state beyond what the task passes in. If you must rely on PowerShell globals (like `$PROFILE`), expose them as overridable parameters with sensible defaults.
- Use `Write-Build`, `Write-Warning`, and `Write-Error` consistently so helper output matches Invoke-Build expectations. Reserve `Write-Verbose` for optional diagnostics.
- Let functions return data instead of writing formatted strings when tasks need to take follow-up action. Helpers that perform side effects should surface success/failure information clearly.
- Do not add `Set-StrictMode` or change `$ErrorActionPreference` inside helper files; inherit the execution environment established by `.build.ps1`.

## Usage expectations

- Dot-source the helper file in the associated task file’s `begin` block using a relative path (e.g., `. ./modules/example.tasks.functions.ps1`).
- Keep helper file paths stable; if a helper moves or new helpers are introduced, update the matching task’s begin block and comment-based help accordingly.
- When a helper function requires updates to repository-wide tooling (like analyzer allow lists), document the change in the relevant instruction file during the same session.
- If a helper needs a suppression attribute for analyzer compliance, place the attribute above the function definition so it remains visible and auditable.
