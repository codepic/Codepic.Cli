---
applyTo: "**"
---

# Codepic CLI instructions index

Use this document as the entry point for repository guidance. Every instruction file lives under `.github/instructions/`; keep this index updated whenever you add, rename, or retire a companion doc.

## Directory model

- **Protocols** define decision-making rules that span the repo. Name them `.protocol.<name>.instructions.md` and keep each as the single source of truth. Reference them from other docs instead of duplicating language so changes happen in one place.
- **Root-module authority files** start with a leading dot (for example `.tasks.instructions.md`, `.tasks.prompt.md`). Treat them as canonical guidance consumed by the root module; downstream modules inherit these patterns unless their own notes call out deliberate deviations.
- **Task-specific guides** provide conventions for concrete assets (for example task files, helper functions, build scripts). Add a short summary here plus a link so readers know where to dive deeper.
- **Module or feature notes** live alongside their subjects (for example `sample.tasks.instructions.md`). Keep those scoped and mention them here only if discoverability would otherwise suffer.

## Protocol library

- `.protocol.alignment.instructions.md` — Standard global alignment workflow. Trigger it when instructions clash or requirements are ambiguous. Always follow the steps in that file; do not restate them elsewhere.

## Global guidance

- `.build.instructions.md` — Expectations for `.build.ps1`, bootstrap behavior, and alias setup.
- `.tasks.instructions.md` — Canonical rules for `*.tasks.ps1` files, including task help, structure, and packaging/clone conventions.
- `.tasks.functions.instructions.md` — Guidance for shared helper scripts that support task files.

## Current module notes

- `sample.tasks.instructions.md` — Context for the sample module shipped with the repo; update when the sample evolves so it stays representative.

## Shared conventions

- Treat `docs/background.md` as required reading before altering workflows; it captures the CLI philosophy and success criteria that guide both human and agentic contributors.
- Use `docs/features.md` to confirm where new work fits; align changes with the documented feature areas or extend the doc concurrently when you introduce a new capability.
- Reference `docs/enablers.md` when optional tooling is introduced so the lifecycle and documentation remain in sync with the slim-core philosophy.
- Keep prerequisite runtimes (for example PowerShell 7+, Git) documented separately from enablers so the base install stays clear to operators.
- Keep workspace-level settings intact (format-on-save, trim trailing whitespace, insert final newline).
- Maintain comment-based help consistently so operators can rely on `Get-Help` output.
- Prefer guard routines to emit `Write-Error` for parameter validation so Invoke-Build output captures the originating command; the bootstrapper sets `$ErrorActionPreference = 'Stop'`, so these remain terminating conditions. Reserve `throw` for scenarios where richer exception metadata is required.
- When introducing new conventions or tooling, update the relevant instruction file in the same session.
- Treat the CLI as implementation agnostic: new modules must be drop-in and avoid assumptions beyond what `.build.ps1` guarantees (automatic task discovery, shared parameters, etc.).
- Honor `PSScriptAnalyzerSettings.ps1`; suppressions require justification in code comments and matching instruction updates.

## Assistant responsibilities

- Anchor architectural or behavioural changes back to the philosophy in `docs/background.md` and update the document when new principles emerge.
- Keep `docs/features.md` synchronized with any net-new feature work so future contributors can map capabilities quickly.
- Record optional tooling in `docs/enablers.md` and update the relevant instruction files before shipping new enablers.
- Run PowerShell commands in the active terminal session whenever possible; avoid launching `pwsh -NoProfile` because the CLI depends on profile-loaded aliases.
- Review all applicable instruction files before editing a target asset.
- Mirror established naming, help text, and structural patterns introduced by the user.
- Document new expectations in the appropriate instruction file so future work stays aligned.
- When instructions conflict or feel ambiguous, invoke the global alignment protocol (`.protocol.alignment.instructions.md`) before changing code.
