---
applyTo: "modules/**/*.tasks.ps1"
---

# Codepic CLI tasks instructions

## Task file conventions

- Each task file must use `[CmdletBinding()]`, a `param` block, and `begin/process/end` segments.
- The root module lives directly under `modules/` (no nested folder) yet follows all conventions outlined here; treat its task file and any helpers the same as module-scoped counterparts.
- The `process` block should declare Invoke-Build `task` definitions that represent CLI commands.
- Keep task names generic across modules (for example, `validate`, `deploy`, `verify`) instead of prefixing them with the module name so operators see consistent verbs everywhere.
- Provide a top-level comment-based help block describing the file’s purpose, accepted parameters, and include a `.EXAMPLE` entry for every task defined inside the file.
- Every individual task must include its own comment-based help (`.SYNOPSIS`, `.DESCRIPTION`, `.EXAMPLE`, etc.) explaining how to invoke it and what parameters it accepts.
- Author task definitions with the Invoke-Build alias `task` (e.g., `task name {}`) instead of calling `Add-BuildTask` directly.
- When introducing shared variables in the `begin` block, name them to describe both what they store and which tasks should consume them, and precede each with comments explaining intended usage and boundaries.
- Keep modules self-contained and drop-in ready: do not assume other modules exist beyond what `.build.ps1` loads automatically. If shared behavior is required, factor it into reusable helpers within the module or document the dependency explicitly.
- Prefer `Write-Build` for task output instead of `Write-Host`; reserve native severity cmdlets (`Write-Warning`, `Write-Error`) for genuine warning/error semantics.
- Keep logging concise: skip progress chatter and rely on Invoke-Build's own task reporting unless additional context is critical for the operator.
- When tooling already emits findings or exit codes (e.g., `Invoke-ScriptAnalyzer -EnableExit`), rely on that behavior instead of raising custom errors.
- Do not override `ErrorAction` on individual commands; honor the `ErrorActionPreference` established by `.build.ps1`.
- Avoid splatting unless it materially simplifies dynamic parameter handling or reuse; prefer direct parameter passing for clarity.
- Skip `[void]` casts or wrapping command invocations in parentheses unless you truly need the returned value; let PowerShell stream output naturally.
- Wrap external tooling invocations in `exec {}` blocks so Invoke-Build can capture exit codes; add `-Echo` when the script block captures variables from the parent scope and place the switch after the script block for readability.
- When passing multiple parameters to tooling, place each named argument on its own line using backtick line continuations; positional arguments may remain alongside the command name.
- Skip pseudo-code or numbered step comments inside tasks; prefer self-explanatory code and add only brief, targeted comments when logic truly needs clarification.
- Do not declare standalone PowerShell functions in task files; all executable logic should live inside Invoke-Build `task {}` scriptblocks or supporting begin/process/end scaffolding.
- Rely on Invoke-Build setting the current working directory; reference files using relative paths (e.g., `./PSScriptAnalyzerSettings.psd1`) instead of constructing absolute paths or manually resolving the repository root.
- Assume all required modules and dependencies are already installed before tasks run; do not add ad-hoc installation or availability checks inside task definitions. Dependency loading belongs in `.build.ps1` or higher-level bootstrap logic.
- Keep each `task {}` concise so contributors without deep PowerShell experience can follow along; when a task approaches ~20 lines, evaluate whether the logic can be simplified, split into smaller Invoke-Build tasks with dependencies, or moved into a companion `*.tasks.functions.ps1` file that you dot-source from the `begin` block for task-specific helpers.
- Name module directories in lowercase (e.g., `modules/hello`) so CLI commands remain predictable and case-insensitive across platforms; the root module continues to live directly under `modules/`.
- Each module must ship with a `module.manifest.json` file that follows the schema defined in `docs/module-manifest.md`. Treat that document as the single source of truth for required fields, path semantics, and lifecycle behaviour.
- Packaging a module should emit an artifact named `<module>.<version>.zip` under `./dist/<module>/`, where `<version>` comes from the manifest. Keep previous versioned archives if you wish, but the latest pack run must update the versioned file and remove the legacy `Module.zip`.
- `unpack-module` requires explicit `-Module` and `-Version` arguments so contributors control exactly which artifact is restored. Do not attempt to infer versions automatically.
- Provide a `clone-module` task that accepts `-Module`, `-Git`, and `-Version` parameters. It should clone the referenced repository to a temporary location, locate a `module.manifest.json` whose `name` and `version` match the supplied values, and copy the manifest's `include` paths into the current repository. Fail fast if the module already exists locally or if the manifest cannot be found/matched. The clone operation must target a Git tag named `v<Version>` to ensure the retrieved files align with the requested module version.
- Provide an `update-module` task that accepts `-Module` and `-Version`, and optionally honors `-Git`. It should read the installed module's manifest source metadata to discover the canonical repository when `-Git` is omitted, check out the requested version tag (respecting any `tagPrefix`), remove the previously installed files, and lay down the new version in their place. Abort if the module is missing locally or if the requested manifest cannot be located in the repository.
- Include a `[Parameter(Mandatory = $false, ValueFromRemainingArguments = $true)]$RestArgs` parameter in every `.tasks.ps1` file so the bootstrapper can splat overflow arguments without causing binding errors.

### Write-Build color guidelines

- Use color only when it communicates status/importance and remains legible in both light/dark themes and Azure DevOps consoles; when uncertain, omit the message or stick to monochrome execution.
- Always supply an explicit color using positional syntax (e.g., `Write-Build Green "message"`) so output remains consistent; uncolored invocations are disallowed.
- Do not mix more than three colors within a single task invocation and avoid macro-level start/end chatter—Invoke-Build already reports task execution.
- Follow the table below when selecting colors:

| Color                     | Use For                                   | Notes / Accessibility                                                    | Policy  |
| ------------------------- | ----------------------------------------- | ------------------------------------------------------------------------ | ------- |
| Gray                      | Low-priority detail / context prefixes    | Subtle but readable                                                      | Allowed |
| Green                     | Positive confirmation / success           | Conventional success color                                               | Allowed |
| Cyan                      | Neutral information / progress updates    | Remains clear on dark and acceptable on light themes                     | Allowed |
| Red                       | Critical halt / precondition failure      | Reserve for actual errors or abort conditions                            | Allowed |
| Magenta                   | Supplemental sub-detail needing attention | Use sparingly (≤1 line per task/iteration)                               | Limited |
| DarkGray / Blue           | Contextual metadata or external refs      | Verify contrast in both themes before committing                         | Limited |
| Other ConsoleColor values |                                           | Introduce only after vetting accessibility and documenting the rationale | Avoid   |

- Yellow is reserved for PowerShell verbose output—do not use it with `Write-Build`.
- Never simulate severity by coloring messages; rely on the proper cmdlets for warnings/errors.
- Skip explicit "Finished"/"Completed" lines—Invoke-Build emits completion status automatically.

## Analyzer tasks

- Provide `lint` and `lint-fix` tasks in the baseline module so contributors can run script analysis locally.
- Both tasks must call `Invoke-ScriptAnalyzer` with the repository-root `PSScriptAnalyzerSettings.ps1` to enforce the cross-platform PowerShell 7 policy.
- The `lint` task should fail the build when diagnostics exist while surfacing each message with native severity cmdlets.
- The `lint-fix` task should execute the analyzer with `-Fix`, then re-run lint to confirm all diagnostics are addressed, and fail if findings remain.
- Treat `PSScriptAnalyzerSettings.psd1` as the authority for workspace-wide allowances (for example, approving Invoke-Build aliases or specifying traversal commands); update that file when a rule adjustment should apply everywhere so both lint tasks and the VS Code UI stay aligned.
- When only a specific task file requires an exception, annotate it with `[Diagnostics.CodeAnalysis.SuppressMessage()]` attributes placed above the script so suppressions remain visible and discoverable; avoid silent or inline suppressions inside task logic.

## Alias and session behavior

- If a task file exposes an alias parameter, ensure it defaults to a sensible value (currently `codepic`) and check for existing aliases via `Get-Alias` before creating new ones.
- When adding aliases to user profiles, append a relative `Set-Alias` command (e.g., `Set-Alias codepic './.build.ps1'`) and reload the profile so the alias is available immediately. Handle conflicts gracefully.

## Assistant responsibilities

- Review existing task files before making changes to respect user customization.
- When adding new tasks or modules, keep comment-help comprehensive so operators can rely on `Get-Help` or inline docs.
- After introducing new conventions or parameters, update this instruction file so future work follows the same standards.
- If conflicting expectations arise, apply the global alignment workflow: propose options (`accept:a|b|c|d`) with pros/cons/blast radius/recommendation and wait for `accept:`, `question:`, or `adjust:` before implementing changes.
